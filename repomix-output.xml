This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
prisma/
  migrations/
    20250319072442_add_report_model/
      migration.sql
    20250319191219_add_repo_tree_model/
      migration.sql
    20250319194634_link_repo_report_user/
      migration.sql
    migration_lock.toml
  schema.prisma
src/
  app/
    about/
      page.tsx
    account/
      page.tsx
    api/
      auth/
        [...all]/
          route.ts
      trpc/
        [trpc]/
          route.ts
    dashboard/
      [reportId]/
        page.tsx
      new/
        page.tsx
      layout.tsx
      page.tsx
    login/
      page.tsx
    layout.tsx
    not-found.tsx
    page.tsx
  components/
    auth/
      login-box.tsx
      sign-in-form.tsx
      sign-up-form.tsx
    dashboard/
      new-report-card.tsx
      new-report-dialog.tsx
      report-card.tsx
    navigation/
      nav-bar.tsx
    ui/
      button.tsx
      card.tsx
      dialog.tsx
      dropdown-menu.tsx
      form.tsx
      input.tsx
      label.tsx
      scroll-area.tsx
      separator.tsx
      tabs.tsx
    file-explorer-footer.tsx
    file-explorer.tsx
  hooks/
    useRepoReport.ts
  lib/
    auth/
      auth-client.ts
      auth.ts
    github/
      content/
        buildRepoTree.ts
        fetchBranch.ts
        fetchGitTree.ts
        getDirectoryContents.ts
        getFileContentFromBlob.ts
        getFileContents.ts
        getRepoTree.ts
        getRootContents.ts
      visualization/
        assignDFSIndices.ts
        decodeContent.ts
        formatTree.ts
        getLanguageBreakdown.ts
        inferFileType.ts
        inferLanguage.ts
      index.ts
      types.ts
      url.ts
    shadcn/
      utils.ts
  server/
    api/
      routers/
        github.ts
        post.ts
        report.ts
      root.ts
      trpc.ts
    db.ts
  styles/
    globals.css
  trpc/
    query-client.ts
    react.tsx
    server.ts
  env.js
.env.example
.eslintrc.cjs
.gitignore
components.json
next.config.js
package.json
postcss.config.js
prettier.config.js
README.md
tailwind.config.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="prisma/migrations/20250319072442_add_report_model/migration.sql">
-- CreateTable
CREATE TABLE "Post" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "name" TEXT NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);

-- CreateTable
CREATE TABLE "user" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "emailVerified" BOOLEAN NOT NULL,
    "image" TEXT,
    "createdAt" DATETIME,
    "updatedAt" DATETIME,
    "role" TEXT,
    "banned" BOOLEAN,
    "banReason" TEXT,
    "banExpires" DATETIME,
    "firstName" TEXT,
    "lastName" TEXT,
    "phone" TEXT
);

-- CreateTable
CREATE TABLE "Report" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "repoUrl" TEXT NOT NULL,
    "content" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "Report_userId_fkey" FOREIGN KEY ("userId") REFERENCES "user" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "session" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "expiresAt" DATETIME NOT NULL,
    "token" TEXT NOT NULL,
    "createdAt" DATETIME,
    "updatedAt" DATETIME,
    "ipAddress" TEXT,
    "userAgent" TEXT,
    "userId" TEXT NOT NULL,
    "impersonatedBy" TEXT,
    CONSTRAINT "session_userId_fkey" FOREIGN KEY ("userId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "account" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "accountId" TEXT NOT NULL,
    "providerId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "accessToken" TEXT,
    "refreshToken" TEXT,
    "idToken" TEXT,
    "accessTokenExpiresAt" DATETIME,
    "refreshTokenExpiresAt" DATETIME,
    "scope" TEXT,
    "password" TEXT,
    "createdAt" DATETIME,
    "updatedAt" DATETIME,
    CONSTRAINT "account_userId_fkey" FOREIGN KEY ("userId") REFERENCES "user" ("id") ON DELETE CASCADE ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "verification" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "identifier" TEXT NOT NULL,
    "value" TEXT NOT NULL,
    "expiresAt" DATETIME NOT NULL,
    "createdAt" DATETIME,
    "updatedAt" DATETIME
);

-- CreateIndex
CREATE INDEX "Post_name_idx" ON "Post"("name");

-- CreateIndex
CREATE UNIQUE INDEX "user_email_key" ON "user"("email");

-- CreateIndex
CREATE UNIQUE INDEX "session_token_key" ON "session"("token");
</file>

<file path="prisma/migrations/20250319191219_add_repo_tree_model/migration.sql">
/*
  Warnings:

  - You are about to drop the column `content` on the `Report` table. All the data in the column will be lost.

*/
-- CreateTable
CREATE TABLE "RepoTree" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "repoUrl" TEXT NOT NULL,
    "treeData" JSONB NOT NULL,
    "updatedAt" DATETIME NOT NULL
);

-- RedefineTables
PRAGMA defer_foreign_keys=ON;
PRAGMA foreign_keys=OFF;
CREATE TABLE "new_Report" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "repoUrl" TEXT NOT NULL,
    "repoTreeId" TEXT,
    "userId" TEXT NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "Report_repoTreeId_fkey" FOREIGN KEY ("repoTreeId") REFERENCES "RepoTree" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "Report_userId_fkey" FOREIGN KEY ("userId") REFERENCES "user" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);
INSERT INTO "new_Report" ("createdAt", "id", "repoUrl", "updatedAt", "userId") SELECT "createdAt", "id", "repoUrl", "updatedAt", "userId" FROM "Report";
DROP TABLE "Report";
ALTER TABLE "new_Report" RENAME TO "Report";
PRAGMA foreign_keys=ON;
PRAGMA defer_foreign_keys=OFF;

-- CreateIndex
CREATE UNIQUE INDEX "RepoTree_repoUrl_key" ON "RepoTree"("repoUrl");
</file>

<file path="prisma/migrations/20250319194634_link_repo_report_user/migration.sql">
/*
  Warnings:

  - Made the column `repoTreeId` on table `Report` required. This step will fail if there are existing NULL values in that column.

*/
-- RedefineTables
PRAGMA defer_foreign_keys=ON;
PRAGMA foreign_keys=OFF;
CREATE TABLE "new_Report" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "repoUrl" TEXT NOT NULL,
    "repoTreeId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "Report_repoTreeId_fkey" FOREIGN KEY ("repoTreeId") REFERENCES "RepoTree" ("id") ON DELETE RESTRICT ON UPDATE CASCADE,
    CONSTRAINT "Report_userId_fkey" FOREIGN KEY ("userId") REFERENCES "user" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);
INSERT INTO "new_Report" ("createdAt", "id", "repoTreeId", "repoUrl", "updatedAt", "userId") SELECT "createdAt", "id", "repoTreeId", "repoUrl", "updatedAt", "userId" FROM "Report";
DROP TABLE "Report";
ALTER TABLE "new_Report" RENAME TO "Report";
PRAGMA foreign_keys=ON;
PRAGMA defer_foreign_keys=OFF;
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "sqlite"
</file>

<file path="src/components/dashboard/new-report-card.tsx">
import { Plus } from "lucide-react";
import { Card } from "~/components/ui/card";

interface NewReportCardProps {
  onClick: () => void;
}

export function NewReportCard({ onClick }: NewReportCardProps) {
  return (
    <Card 
      className="hover:bg-accent transition-colors cursor-pointer flex items-center justify-center h-[120px]"
      onClick={onClick}
    >
      <Plus className="h-8 w-8 text-muted-foreground" />
    </Card>
  );
}
</file>

<file path="src/components/dashboard/new-report-dialog.tsx">
import { useState } from "react";
import { useRouter } from "next/navigation";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "~/components/ui/dialog";
import { Input } from "~/components/ui/input";
import { Button } from "~/components/ui/button";

interface NewReportDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function NewReportDialog({ open, onOpenChange }: NewReportDialogProps) {
  const router = useRouter();
  const [url, setUrl] = useState("");
  const [isValid, setIsValid] = useState(true);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    try {
      new URL(url); // Validate URL
      router.push(`/dashboard/new?repoUrl=${encodeURIComponent(url)}`);
      onOpenChange(false); // Close dialog
    } catch {
      setIsValid(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Add New Report</DialogTitle>
        </DialogHeader>
        <form onSubmit={handleSubmit} className="space-y-4">
          <Input
            placeholder="Enter GitHub repository URL"
            value={url}
            onChange={(e) => {
              setUrl(e.target.value);
              setIsValid(true); // Reset validation on change
            }}
          />
          {!isValid && (
            <p className="text-sm text-destructive">Please enter a valid URL</p>
          )}
          <Button type="submit" className="w-full">
            Create Report
          </Button>
        </form>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/dashboard/report-card.tsx">
import Link from "next/link";
import { Card, CardHeader, CardTitle } from "~/components/ui/card";

interface ReportCardProps {
  id: string;
  repoUrl: string;
}

export function ReportCard({ id, repoUrl }: ReportCardProps) {
  return (
    <Link href={`/dashboard/${id}`}>
      <Card className="hover:bg-accent transition-colors">
        <CardHeader>
          <CardTitle className="text-lg truncate">{repoUrl}</CardTitle>
        </CardHeader>
      </Card>
    </Link>
  );
}
</file>

<file path="src/components/navigation/nav-bar.tsx">
"use client";

import Link from "next/link"
import { useRouter } from "next/navigation";
import { Github, User } from "lucide-react"
import { useSession, signOut } from "~/lib/auth/auth-client";
import { Button } from "../ui/button";
import { Separator } from "../ui/separator";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "../ui/dropdown-menu";
import {getSession} from "better-auth/api";

export function NavBar() {
  const router = useRouter();
  const { data: session } = useSession();
  console.log(useSession().data)

  return (
    <nav className="w-full border-b">
      <div className="flex h-16 items-center container mx-auto">
        <div className="flex items-center justify-between w-full">
          <Link href="/" className="text-xl font-bold">
            CodeBrief
          </Link>
          
          <div className="flex items-center space-x-6">
            <Link href="/about" className="text-sm font-medium transition-colors hover:text-primary">
              About
            </Link>
            <Link 
              href="https://github.com/EzraApple"
              target="_blank"
              rel="noopener noreferrer"
              className="hover:text-primary transition-colors"
            >
              <Github className="h-5 w-5" />
            </Link>
            <Separator orientation="vertical" className="h-6" />
            {session ? (
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="ghost" className="relative h-8 w-8 rounded-full">
                    <User className="h-5 w-5" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent className="w-56" align="end" forceMount>
                  <p className="px-2 py-1.5 text-sm font-medium">
                    {session.user.name}
                  </p>
                  <DropdownMenuSeparator />
                  <DropdownMenuItem asChild>
                    <Link href="/account">Account</Link>
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    onClick={async () => {
                      await signOut();
                      router.push("/");
                    }}
                    className="text-red-600 cursor-pointer"
                  >
                    Sign Out
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            ) : (
              <Link
                href="/login"
                className="text-sm font-medium transition-colors hover:text-primary"
              >
                Sign In
              </Link>
            )}
          </div>
        </div>
      </div>
    </nav>
  )
}
</file>

<file path="src/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "~/lib/shadcn/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="src/components/ui/scroll-area.tsx">
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "~/lib/shadcn/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
</file>

<file path="src/components/file-explorer-footer.tsx">
import {calculateLanguageBreakdown, RepoTreeNode} from "~/lib/github";

export function FileExplorerFooter({ tree }: { tree: RepoTreeNode[] }) {
    // Calculate the language breakdown using your getLanguageBreakdown helper
    const breakdown = calculateLanguageBreakdown(tree);

    return (
        <div className="mb-4 border-t p-4">
            <h3 className="mb-2 text-sm font-semibold">Languages</h3>
            {/* The horizontal bar */}
            <div className="mb-3 flex h-4 w-full overflow-hidden rounded bg-muted">
                {breakdown.map((item) => (
                    <div
                        key={item.language}
                        className="h-full"
                        style={{
                            width: `${item.percentage}%`,
                            backgroundColor: item.color,
                        }}
                        title={`${item.language}: ${item.percentage.toFixed(1)}%`}
                    />
                ))}
            </div>

            {/* The legend */}
            <div className="flex flex-wrap gap-3 text-sm">
                {breakdown.map((item) => (
                    <div className="flex items-center gap-2" key={item.language}>
            <span
                className="inline-block h-3 w-3 rounded-full"
                style={{ backgroundColor: item.color }}
            />
                        <span>
              {item.language} {item.percentage.toFixed(1)}%
            </span>
                    </div>
                ))}
            </div>
        </div>
    );
}
</file>

<file path="src/components/file-explorer.tsx">
"use client";

import React, { useState, useEffect } from "react";
import { ChevronRight, ChevronDown, File, Folder } from "lucide-react";
import { Button } from "~/components/ui/button";
import { Separator } from "~/components/ui/separator";
import { ScrollArea } from "~/components/ui/scroll-area";
import { cn } from "~/lib/shadcn/utils";
import { FileExplorerFooter } from "~/components/file-explorer-footer";

// ------------------------------
// Types & DFS Index Assignment
// ------------------------------

export type RepoTreeNode = {
    name: string;
    type: "file" | "dir";
    children?: RepoTreeNode[];
};

export type DFSRepoTreeNode = RepoTreeNode & {
    dfsIndex: number;
    children?: DFSRepoTreeNode[];
};

function assignDFSIndices(tree: RepoTreeNode[]): DFSRepoTreeNode[] {
    let currentIndex = 0;

    function traverse(node: RepoTreeNode): DFSRepoTreeNode {
        const dfsNode: DFSRepoTreeNode = {
            ...node,
            dfsIndex: currentIndex++,
        };
        if (node.children) {
            dfsNode.children = node.children.map(traverse);
        }
        return dfsNode;
    }

    return tree.map(traverse);
}

// ------------------------------
// TreeNode
// ------------------------------

type TreeNodeProps = {
    node: DFSRepoTreeNode;
    delay?: number;
    defaultExpanded?: boolean;
    initialAnimationDone?: boolean;
    depth?: number; // indicates nesting level for indentation and lines
};

function TreeNode({
                      node,
                      delay = 50,
                      defaultExpanded = true,
                      initialAnimationDone: globalAnimationDone = false,
                      depth = 0,
                  }: TreeNodeProps) {
    const [isOpen, setIsOpen] = useState(defaultExpanded);
    const [localAnimationDone, setLocalAnimationDone] = useState(globalAnimationDone);

    useEffect(() => {
        // If the global animation is already finished, skip local fade-in.
        if (globalAnimationDone) {
            setLocalAnimationDone(true);
        } else {
            const timer = setTimeout(() => {
                setLocalAnimationDone(true);
            }, node.dfsIndex * delay);
            return () => clearTimeout(timer);
        }
    }, [globalAnimationDone, node.dfsIndex, delay]);

    // Apply the same fade/slide style to the entire node container (including lines).
    const nodeStyle: React.CSSProperties = {
        transition: globalAnimationDone
            ? "none"
            : "opacity 300ms ease-out, transform 300ms ease-out",
        opacity: localAnimationDone ? 1 : 0,
        transform: localAnimationDone ? "translateY(0)" : "translateY(-8px)",
    };

    const isDirectory = node.type === "dir";
    const hasChildren = isDirectory && node.children && node.children.length > 0;

    const toggleOpen = () => setIsOpen((prev) => !prev);

    return (
        <div className="relative" style={{ marginLeft: depth * 16 }}>
            <div
                className="relative flex items-center h-8"
                style={nodeStyle}
            >
                <Button
                    variant="ghost"
                    size="sm"
                    className={cn("ml-4 w-full justify-start gap-2 px-2 hover:bg-accent")}
                    onClick={() => hasChildren && toggleOpen()}
                >
                    {/* Expand/collapse chevron */}
                    {isDirectory ? (
                        hasChildren ? (
                            isOpen ? (
                                <ChevronDown className="h-4 w-4 shrink-0 text-muted-foreground" />
                            ) : (
                                <ChevronRight className="h-4 w-4 shrink-0 text-muted-foreground" />
                            )
                        ) : (
                            <div className="w-4" />
                        )
                    ) : (
                        <div className="w-4" />
                    )}
                    {/* Folder/File icon */}
                    {isDirectory ? (
                        <Folder className="h-4 w-4 shrink-0 text-muted-foreground" />
                    ) : (
                        <File className="h-4 w-4 shrink-0 text-muted-foreground" />
                    )}
                    <span className="truncate">{node.name}</span>
                </Button>
            </div>

            {isOpen && hasChildren && (
                <div className="relative" style={{ marginLeft: 6 }}>
                    <span className="absolute left-6 top-0 bottom-0 border-l border-border" />
                    <div className="ml-0">
                        {node.children?.map((child) => (
                            <TreeNode
                                key={child.dfsIndex}
                                node={child}
                                delay={delay}
                                defaultExpanded={defaultExpanded}
                                initialAnimationDone={globalAnimationDone}
                                depth={depth + 1}
                            />
                        ))}
                    </div>
                </div>
            )}


        </div>
    );
}

// ------------------------------
// FileExplorer
// ------------------------------

export type FileExplorerProps = {
    tree: RepoTreeNode[];
    delay?: number;
    defaultExpanded?: boolean;
    title?: string;
    className?: string;
};

export function FileExplorer({
                                 tree,
                                 title,
                                 delay = 50,
                                 defaultExpanded = true,
                                 className,
                             }: FileExplorerProps) {
    // Annotate the tree with DFS indices
    const annotatedTree = assignDFSIndices(tree);

    // Determine the maximum DFS index in the tree
    let maxDfsIndex = 0;
    (function traverse(nodes: DFSRepoTreeNode[]) {
        for (const node of nodes) {
            maxDfsIndex = Math.max(maxDfsIndex, node.dfsIndex);
            if (node.children && node.children.length) {
                traverse(node.children);
            }
        }
    })(annotatedTree);

    // total time = max DFS index * delay + fade-in duration
    const totalAnimationTime = maxDfsIndex * delay + 300;
    const [initialAnimationDone, setInitialAnimationDone] = useState(false);

    useEffect(() => {
        const timer = setTimeout(() => {
            setInitialAnimationDone(true);
        }, totalAnimationTime);
        return () => clearTimeout(timer);
    }, [totalAnimationTime]);

    return (
        <div
            className={cn(
                "w-full rounded-lg border bg-card text-card-foreground shadow-sm hover:shadow-md transition-shadow duration-200",
                className
            )}
        >
            <div className="flex h-full flex-col">
                {title && (
                    <div className="p-4">
                        <div className="flex items-center">
                            <h2 className="text-lg font-semibold tracking-tight">{title}</h2>
                        </div>
                        <Separator className="my-4 bg-border" />
                    </div>
                )}
                <ScrollArea className="flex-1 h-[calc(100vh-20rem)]">
                    <div className="p-4 space-y-1">
                        {annotatedTree.map((node) => (
                            <TreeNode
                                key={node.dfsIndex}
                                node={node}
                                delay={delay}
                                defaultExpanded={defaultExpanded}
                                initialAnimationDone={initialAnimationDone}
                                depth={0} // Root level
                            />
                        ))}
                    </div>
                </ScrollArea>
                {annotatedTree.length > 0 && <FileExplorerFooter tree={tree} />}
            </div>
        </div>
    );
}
</file>

<file path="src/hooks/useRepoReport.ts">
"use client";

import { useEffect, useRef, useState } from "react";
import { api } from "~/trpc/react";
import type { RepoTreeNode } from "~/lib/github/visualization/formatTree";
import { useSession } from "~/lib/auth/auth-client";
import { extractRepoInfo } from "~/lib/github/url";

export type UseRepoReportReturn = {
    treeData: RepoTreeNode[] | null;
    isLoading: boolean;
    error: unknown;
    title: string;
};

export function useRepoReport(repoUrl: string | null): UseRepoReportReturn {
    const session = useSession();
    const userId = session?.data?.session?.userId || undefined;
    const [treeData, setTreeData] = useState<RepoTreeNode[] | null>(null);
    const [title, setTitle] = useState("");
    const hasSetTreeRef = useRef(false);

    // Compute a title (e.g. "owner / repo") from the repoUrl.
    useEffect(() => {
        if (repoUrl) {
            try {
                const info = extractRepoInfo(repoUrl);
                setTitle(`${info.owner} / ${info.repo}`);
            } catch (err) {
                console.error("Error extracting repo info:", err);
                setTitle("");
            }
        }
    }, [repoUrl]);

    const { data, isLoading, error } = api.github.getRepoTreeCached.useQuery(
        { repoUrl: repoUrl || "", userId },
        {
            enabled: Boolean(repoUrl),
            onSuccess: (result) => {
                if (result?.treeData && !hasSetTreeRef.current) {
                    setTreeData(result.treeData);
                    hasSetTreeRef.current = true;
                }
            },
        }
    );

    const finalTreeData = treeData || data?.treeData || null;

    return { treeData: finalTreeData, isLoading, error, title };
}
</file>

<file path="src/lib/github/visualization/assignDFSIndices.ts">
// src/lib/github/visualization/assignDFSIndices.ts
import type { RepoTreeNode } from "./formatTree";

export type DFSRepoTreeNode = RepoTreeNode & { dfsIndex: number };

export function assignDFSIndices(tree: RepoTreeNode[]): DFSRepoTreeNode[] {
    let index = 0;
    function traverse(nodes: RepoTreeNode[]): DFSRepoTreeNode[] {
        return nodes.map((node) => {
            const currentIndex = index++;
            const newNode: DFSRepoTreeNode = { ...node, dfsIndex: currentIndex };
            if (node.children) {
                newNode.children = traverse(node.children);
            }
            return newNode;
        });
    }
    return traverse(tree);
}
</file>

<file path="src/lib/github/visualization/getLanguageBreakdown.ts">
// src/lib/github/visualization/getLanguageBreakdown.ts

import type { RepoTreeNode } from "./formatTree";
import { inferLanguage } from "./inferLanguage";

export type LanguageBreakdown = {
    language: string;
    percentage: number;
    color: string;
};

function calculateLanguageCounts(tree: RepoTreeNode[]): Record<string, { count: number; color: string }> {
    const counts: Record<string, { count: number; color: string }> = {};

    function traverse(nodes: RepoTreeNode[]) {
        nodes.forEach((node) => {
            if (node.type === "file") {
                const detail = inferLanguage(node.name);
                if (detail) {
                    if (!counts[detail.language]) {
                        counts[detail.language] = { count: 0, color: detail.color };
                    }
                    counts[detail.language].count++;
                }
            } else if (node.type === "dir" && node.children) {
                traverse(node.children);
            }
        });
    }

    traverse(tree);
    return counts;
}

export function calculateLanguageBreakdown(tree: RepoTreeNode[]): LanguageBreakdown[] {
    const counts = calculateLanguageCounts(tree);
    const total = Object.values(counts).reduce((sum, item) => sum + item.count, 0);
    const breakdown: LanguageBreakdown[] = [];

    for (const language in counts) {
        const { count, color } = counts[language];
        breakdown.push({
            language,
            percentage: total > 0 ? (count / total) * 100 : 0,
            color,
        });
    }
    return breakdown;
}
</file>

<file path="src/lib/github/visualization/inferLanguage.ts">
// src/lib/github/visualization/inferLanguage.ts

export type LanguageDetail = {
    language: string;
    color: string;
};

export function inferLanguage(filename: string): LanguageDetail | null {
    const parts = filename.split(".");
    if (parts.length < 2) return null;
    const ext = parts.pop()?.toLowerCase();

    switch (ext) {
        // TypeScript / JavaScript
        case "ts":
        case "tsx":
            return { language: "TypeScript", color: "#3178c6" };
        case "js":
        case "jsx":
            return { language: "JavaScript", color: "#f1e05a" };

        // Python
        case "py":
            return { language: "Python", color: "#3572A5" };

        // Java
        case "java":
            return { language: "Java", color: "#b07219" };

        // Ruby
        case "rb":
            return { language: "Ruby", color: "#701516" };

        // PHP
        case "php":
            return { language: "PHP", color: "#4F5D95" };

        // C# / .NET
        case "cs":
            return { language: "C#", color: "#178600" };

        // C / C++ / Headers
        case "cpp":
        case "c":
        case "h":
        case "hpp":
            return { language: "C/C++", color: "#f34b7d" };

        // Go
        case "go":
            return { language: "Go", color: "#00ADD8" };

        // Shell
        case "sh":
        case "bash":
        case "zsh":
        case "ksh":
            return { language: "Shell", color: "#89e051" };

        // HTML
        case "html":
        case "htm":
            return { language: "HTML", color: "#e34c26" };

        // CSS / SCSS
        case "css":
            return { language: "CSS", color: "#563d7c" };
        case "scss":
            return { language: "SCSS", color: "#c6538c" };

        // YAML
        case "yml":
        case "yaml":
            return { language: "YAML", color: "#cb171e" };

        // Swift
        case "swift":
            return { language: "Swift", color: "#F05138" };

        // Rust
        case "rs":
            return { language: "Rust", color: "#dea584" };

        // Kotlin
        case "kt":
        case "kts":
            return { language: "Kotlin", color: "#A97BFF" };

        default:
            return null;
    }
}
</file>

<file path="src/server/api/routers/report.ts">
// src/server/api/trpc/routers/report.ts
import { z } from "zod";
import { createTRPCRouter, publicProcedure } from "../trpc";
import { db } from "~/server/db";

export const reportRouter = createTRPCRouter({
    // Create a new report for the user.
    create: publicProcedure
        .input(
            z.object({
                userId: z.string(),
                repoUrl: z.string().url(),
                content: z.string(),
            })
        )
        .mutation(async ({ input }) => {
            return db.report.create({
                data: {
                    repoUrl: input.repoUrl,
                    content: input.content,
                    userId: input.userId,
                },
            });
        }),

    // Retrieve a report by its ID for the user.
    getById: publicProcedure
        .input(z.object({ id: z.string(), userId: z.string() }))
        .query(async ({ input }) => {
            return db.report.findFirst({
                where: {
                    id: input.id,
                    userId: input.userId,
                },
            });
        }),

    // Retrieve all reports for the user.
    getByUserId: publicProcedure
        .input(z.object({ userId: z.string() }))
        .query(async ({ input }) => {
            return db.report.findMany({
                where: {
                    userId: input.userId,
                },
                orderBy: { createdAt: "desc" },
            });
        }),

    // Update an existing report.
    update: publicProcedure
        .input(
            z.object({
                id: z.string(),
                userId: z.string(),
                repoUrl: z.string().url().optional(),
                content: z.string().optional(),
            })
        )
        .mutation(async ({ input }) => {
            return db.report.updateMany({
                where: {
                    id: input.id,
                    userId: input.userId,
                },
                data: {
                    repoUrl: input.repoUrl,
                    content: input.content,
                },
            });
        }),

    // Delete a report.
    delete: publicProcedure
        .input(z.object({ id: z.string(), userId: z.string() }))
        .mutation(async ({ input }) => {
            return db.report.deleteMany({
                where: {
                    id: input.id,
                    userId: input.userId,
                },
            });
        }),

    upsert: publicProcedure
        .input(
            z.object({
                userId: z.string(),
                repoUrl: z.string().url(),
            })
        )
        .mutation(async ({ input }) => {
            // Check if a report already exists for this user & repo.
            const existingReport = await db.report.findFirst({
                where: {
                    userId: input.userId,
                    repoUrl: input.repoUrl,
                },
            });
            if (existingReport) {
                return existingReport;
            }
            // Look up the RepoTree record.
            const repoTree = await db.repoTree.findUnique({
                where: { repoUrl: input.repoUrl },
            });
            if (!repoTree) {
                throw new Error("Repository tree not found in database. Please try again later.");
            }
            // Create a new report that links to the cached repo tree.
            return db.report.create({
                data: {
                    repoUrl: input.repoUrl,
                    userId: input.userId,
                    repoTreeId: repoTree.id,
                },
            });
        }),

    // Find a report by repoUrl for the user.
    findByRepoUrl: publicProcedure
        .input(
            z.object({
                userId: z.string(),
                repoUrl: z.string().url(),
            })
        )
        .query(async ({ input }) => {
            return db.report.findFirst({
                where: {
                    repoUrl: input.repoUrl,
                    userId: input.userId,
                },
            });
        }),
});
</file>

<file path="src/app/about/page.tsx">
export default function AboutPage() {
  return (
    <main className="container mx-auto p-4">
      <h1 className="text-4xl font-bold">About</h1>
    </main>
  );
}
</file>

<file path="src/app/account/page.tsx">
"use client";

import { useSession } from "~/lib/auth/auth-client";

export default function AccountPage() {
  const { data: session } = useSession();

  return (
    <main className="container mx-auto p-4">
      <h1 className="text-4xl font-bold mb-8">Account Settings</h1>
      {session && (
        <div className="space-y-4">
          <div>
            <h2 className="text-lg font-semibold">Username</h2>
            <p className="text-muted-foreground">{session.user.name}</p>
          </div>
          <div>
            <h2 className="text-lg font-semibold">Email</h2>
            <p className="text-muted-foreground">{session.user.email}</p>
          </div>
        </div>
      )}
    </main>
  );
}
</file>

<file path="src/app/api/auth/[...all]/route.ts">
import { auth } from "~/lib/auth/auth"; // path to your auth file
import { toNextJsHandler } from "better-auth/next-js";

export const { POST, GET } = toNextJsHandler(auth);
</file>

<file path="src/app/dashboard/[reportId]/page.tsx">
export default async function ReportPage({
  params,
}: {
  params: { reportId: string };
}) {
  const { reportId } = await params;
  
  return (
    <main className="p-4">
      <h1 className="text-4xl font-bold">Report {reportId}</h1>
    </main>
  );
}
</file>

<file path="src/app/dashboard/layout.tsx">
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="container mx-auto">
      {children}
    </div>
  );
}
</file>

<file path="src/app/dashboard/page.tsx">
"use client";

import { useState } from "react";
import { useSession } from "~/lib/auth/auth-client";
import { api } from "~/trpc/react";
import { ReportCard } from "~/components/dashboard/report-card";
import { NewReportCard } from "~/components/dashboard/new-report-card";
import { NewReportDialog } from "~/components/dashboard/new-report-dialog";

interface Report {
  id: string;
  repoUrl: string;
}

export default function DashboardPage() {
  const { data: session } = useSession();
  const [dialogOpen, setDialogOpen] = useState(false);
  
  const { data: reports, isLoading } = api.report.getByUserId.useQuery(
    { userId: session?.user?.id ?? "" },
    { enabled: Boolean(session?.user?.id) }
  );

console.log(session)
  return (
    <main className="container mx-auto p-4">
      <h1 className="text-4xl font-bold mb-8">Your Reports</h1>
      
      {isLoading && <p>Loading your reports...</p>}
      
      <div className="grid gap-4 grid-cols-1 md:grid-cols-2 lg:grid-cols-3">
        <NewReportCard onClick={() => setDialogOpen(true)} />
        {reports?.map((report: Report) => (
          <ReportCard
            key={report.id}
            id={report.id}
            repoUrl={report.repoUrl}
          />
        ))}
      </div>
      
      {reports?.length === 0 && (
        <p className="text-muted-foreground">
          You haven&#39;t created any reports yet.
        </p>
      )}

      <NewReportDialog 
        open={dialogOpen}
        onOpenChange={setDialogOpen}
      />
    </main>
  );
}
</file>

<file path="src/app/not-found.tsx">
import Link from "next/link"
import { Button } from "~/components/ui/button"

export default function NotFound() {
  return (
      <div className="container flex max-w-2xl flex-col items-center gap-8 text-center">
        <h1 className="text-4xl font-bold">404</h1>
        <p className="text-xl text-muted-foreground">
          Page not found
        </p>
        <Button asChild>
          <Link href="/">
            Return Home
          </Link>
        </Button>
      </div>
  )
}
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "~/lib/shadcn/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "~/lib/shadcn/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="src/components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "~/lib/shadcn/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
</file>

<file path="src/components/ui/form.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "~/lib/shadcn/utils"
import { Label } from "~/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-[0.8rem] text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-[0.8rem] font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "~/lib/shadcn/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
</file>

<file path="src/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "~/lib/shadcn/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
</file>

<file path="src/components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "~/lib/shadcn/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="src/components/ui/tabs.tsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "~/lib/shadcn/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="src/lib/auth/auth-client.ts">
import { createAuthClient } from "better-auth/react"
import { env } from "~/env";

export const { signIn, signOut, signUp, useSession } = createAuthClient({
    baseURL: env.NEXT_PUBLIC_BETTER_AUTH_URL
})
</file>

<file path="src/lib/auth/auth.ts">
import { betterAuth } from "better-auth";
import { prismaAdapter } from "better-auth/adapters/prisma";
import { db } from "~/server/db";

export const auth = betterAuth({
    emailAndPassword: {
        enabled: true,
    },
    database: prismaAdapter(db, {
        provider: 'sqlite'
    }),
});
</file>

<file path="src/lib/github/content/buildRepoTree.ts">
// lib/github/contents/buildRepoTree.ts

import type { GitTreeNode, RepoTreeNode } from "../types";

/**
 * Builds a nested repository tree structure from a flat array of Git tree nodes.
 *
 * @param flatNodes - The flat array of GitTreeNode objects.
 * @param maxDepth - Maximum depth to include (1 = only root level)
 * @returns A nested array of RepoTreeNode.
 */
export function buildRepoTree(
    flatNodes: GitTreeNode[],
    maxDepth: number
): RepoTreeNode[] {
    // Create a root container
    const root: RepoTreeNode = { name: "", type: "dir", children: [] };

    for (const node of flatNodes) {
        // Split path into parts (directories/files)
        const parts = node.path.split("/");
        // Limit depth if necessary
        if (maxDepth > 0 && parts.length > maxDepth) {
            parts.splice(maxDepth);
        }
        let current = root;
        for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            if (!current.children) {
                current.children = [];
            }
            let child = current.children.find(c => c.name === part);
            if (!child) {
                child = {
                    name: part,
                    // For the last segment, use the type from the GitTreeNode.
                    type: i === parts.length - 1 ? (node.type === "blob" ? "file" : "dir") : "dir",
                    children: [],
                };
                current.children.push(child);
            }
            current = child;
        }
    }

    return root.children ?? [];
}
</file>

<file path="src/lib/github/content/fetchBranch.ts">
// lib/github/contents/fetchBranch.ts

import type { GitBranch } from "../types";

/**
 * Fetches branch data from GitHub for a given branch.
 *
 * @param baseUrl - The base GitHub API URL for the repository.
 * @param branch - The branch name (default is "main").
 * @returns A promise that resolves to the GitBranch data.
 */
export async function fetchBranch(
    baseUrl: string,
    branch: string = "main"
): Promise<GitBranch> {
    const url = `${baseUrl}/branches/${branch}`;
    const res = await fetch(url);
    if (!res.ok) {
        throw new Error(`Failed to fetch branch info: ${res.statusText}`);
    }
    const data: GitBranch = await res.json();
    return data;
}
</file>

<file path="src/lib/github/content/fetchGitTree.ts">
// lib/github/contents/fetchGitTree.ts

import type { GitTreeResponse } from "../types";

/**
 * Fetches the Git tree for a repository.
 *
 * @param baseUrl - The base GitHub API URL for the repo (e.g., "https://api.github.com/repos/owner/repo")
 * @param treeSha - The SHA of the tree to fetch (for the root tree, you can get this from the repo data)
 * @param recursive - Whether to fetch recursively (default false)
 * @returns A GitTreeResponse containing the tree array.
 */
export async function fetchGitTree(
    baseUrl: string,
    treeSha: string,
    recursive = false
): Promise<GitTreeResponse> {
    const url = `${baseUrl}/git/trees/${treeSha}${recursive ? "?recursive=1" : ""}`;
    const res = await fetch(url);
    if (!res.ok) {
        throw new Error(`Failed to fetch git tree: ${res.statusText}`);
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return await res.json();
}
</file>

<file path="src/lib/github/content/getDirectoryContents.ts">
import type { GitHubContent } from "../types";

/**
 * Fetches the contents of a directory.
 * @param baseUrl - The base GitHub API URL (e.g., "https://api.github.com/repos/owner/repo")
 * @param path - Optional: The directory path relative to the repo root. If omitted, fetches root contents.
 * @returns An array of GitHubContent representing the directory's contents.
 */
export async function getDirectoryContents(
    baseUrl: string,
    path?: string
): Promise<GitHubContent[]> {
    const endpoint = path ? `/contents/${encodeURIComponent(path)}` : "/contents";
    const url = `${baseUrl}${endpoint}`;
    const res = await fetch(url);
    if (!res.ok) {
        throw new Error(`Failed to fetch directory contents for ${path ?? "root"}: ${res.statusText}`);
    }
    return await res.json();
}
</file>

<file path="src/lib/github/content/getFileContentFromBlob.ts">
// lib/github/contents/getFileContentFromBlob.ts

/**
 * Fetches file content using the Git Blob API.
 *
 * @param baseUrl - The base GitHub API URL for the repo.
 * @param sha - The blob SHA for the file.
 * @returns The decoded file content as a string.
 */
export async function getFileContentFromBlob(
    baseUrl: string,
    sha: string
): Promise<string> {
    const url = `${baseUrl}/git/blobs/${sha}`;
    const res = await fetch(url);
    if (!res.ok) {
        throw new Error(`Failed to fetch blob content: ${res.statusText}`);
    }
    const data = await res.json();
    if (data.encoding === "base64") {
        return Buffer.from(data.content, "base64").toString("utf-8");
    }
    return data.content;
}
</file>

<file path="src/lib/github/content/getFileContents.ts">
import type { GitHubContent } from "../types";

/**
 * Fetches the contents of a specific file.
 * @param baseUrl - The base GitHub API URL (e.g., "https://api.github.com/repos/owner/repo")
 * @param path - The file path relative to the repo root.
 * @returns A GitHubContent object with file details and content.
 */
export async function getFileContents(
    baseUrl: string,
    path: string
): Promise<GitHubContent> {
    const url = `${baseUrl}/contents/${encodeURIComponent(path)}`;
    const res = await fetch(url);
    if (!res.ok) {
        throw new Error(`Failed to fetch file contents for ${path}: ${res.statusText}`);
    }
    return await res.json();
}
</file>

<file path="src/lib/github/content/getRepoTree.ts">
import { getDirectoryContents } from "~/lib/github";

export type RepoTreeNode = {
    name: string;
    type: "file" | "dir";
    children?: RepoTreeNode[];
};

/**
 * Recursively builds a file tree structure.
 *
 * @param baseUrl - The base GitHub API URL (e.g., "https://api.github.com/repos/owner/repo")
 * @param path - The directory path to start from (empty string for root).
 * @param depth - Optional. How deep to traverse. If provided (e.g., 1 = current directory only),
 *                if omitted, the function will recursively fetch the entire tree.
 * @returns An array of RepoTreeNode representing the file/directory structure.
 */
export async function getRepoTree(
    baseUrl: string,
    path = "",
    depth?: number
): Promise<RepoTreeNode[]> {
    const contents = await getDirectoryContents(baseUrl, path);
    const tree: RepoTreeNode[] = [];

    for (const item of contents) {
        const node: RepoTreeNode = {
            name: item.name,
            type: item.type,
        };

        if (item.type === "dir" && (depth === undefined || depth > 1)) {
            const newPath = path ? `${path}/${item.name}` : item.name;
            const newDepth = depth === undefined ? undefined : depth - 1;
            node.children = await getRepoTree(baseUrl, newPath, newDepth);
        }

        tree.push(node);
    }

    return tree;
}
</file>

<file path="src/lib/github/content/getRootContents.ts">
import type { GitHubContent } from "../types";

/**
 * Fetches the top-level contents of a repository.
 * @param baseUrl - The base GitHub API URL (e.g., "https://api.github.com/repos/owner/repo")
 * @returns An array of GitHubContent representing the root directory.
 */
export async function getRootContents(baseUrl: string): Promise<GitHubContent[]> {
    const url = `${baseUrl}/contents`;
    const res = await fetch(url);
    if (!res.ok) {
        throw new Error(`Failed to fetch root contents: ${res.statusText}`);
    }
    return await res.json();
}
</file>

<file path="src/lib/github/visualization/decodeContent.ts">
// lib/github/visualization/decodeContent.ts

/**
 * Decodes a base64-encoded string into UTF-8 text.
 *
 * @param encoded - The base64-encoded string.
 * @returns The decoded text.
 */
export function decodeTextContent(encoded: string): string {
    return Buffer.from(encoded, "base64").toString("utf-8");
}

/**
 * Decodes base64-encoded image content into a data URL.
 *
 * @param encoded - The base64-encoded image content.
 * @param filename - The filename used to infer the MIME type.
 * @returns A data URL string (e.g., "data:image/png;base64,...").
 */
export function decodeImageContent(encoded: string, filename: string): string {
    const parts = filename.split(".");
    const extension = parts.length > 1 ? parts.pop()?.toLowerCase() : "";
    let mimeType = "image/png"; // default
    switch (extension) {
        case "jpg":
        case "jpeg":
            mimeType = "image/jpeg";
            break;
        case "gif":
            mimeType = "image/gif";
            break;
        case "bmp":
            mimeType = "image/bmp";
            break;
        case "svg":
            mimeType = "image/svg+xml";
            break;
        // Add more cases as needed
    }
    return `data:${mimeType};base64,${encoded}`;
}
</file>

<file path="src/lib/github/visualization/formatTree.ts">
// lib/github/visualization/formatTree.ts

export type RepoTreeNode = {
    name: string;
    type: "file" | "dir";
    children?: RepoTreeNode[];
};

// Private recursive helper that builds the tree string.
function buildTreeMarkdown(
    tree: RepoTreeNode[],
    prefix = ""
): string {
    let md = "";
    tree.forEach((node, index) => {
        const isLast = index === tree.length - 1;
        const connector = isLast ? "└── " : "├── ";
        md += prefix + connector + node.name + "\n";
        if (node.children && node.children.length > 0) {
            const newPrefix = prefix + (isLast ? "    " : "│   ");
            md += buildTreeMarkdown(node.children, newPrefix);
        }
    });
    return md;
}

/**
 * Generates an ASCII tree of the repository structure wrapped in a Markdown code block.
 *
 * @param tree - An array of repository tree nodes.
 * @returns A Markdown formatted string of the tree.
 *
 * Example output:
 * ```text
 * ├── file1
 * ├── file2
 * └── dir1
 *     ├── file3
 *     └── file4
 * ```
 */
export function formatRepoTreeToMarkdown(
    tree: RepoTreeNode[]
): string {
    const md = buildTreeMarkdown(tree);
    return "```text\n" + md + "\n```";
}
</file>

<file path="src/lib/github/visualization/inferFileType.ts">
// lib/github/visualization/inferFileType.ts

export type FileType = "image" | "code" | "text" | "unknown";

/**
 * Infers the file type based on the filename extension.
 *
 * @param filename - The name of the file.
 * @returns "image" if it is an image file, "code" for common code extensions,
 *          "text" for markdown or plain text, otherwise "unknown".
 */
export function inferFileType(filename: string): FileType {
    const parts = filename.split(".");
    if (parts.length < 2) return "unknown";
    const extension = parts.pop()?.toLowerCase() ?? "";

    const imageExtensions = ["png", "jpg", "jpeg", "gif", "bmp", "svg"];
    const codeExtensions = [
        "js",
        "ts",
        "jsx",
        "tsx",
        "py",
        "java",
        "c",
        "cpp",
        "cs",
        "rb",
        "go",
        "rs",
        "php",
    ];
    const textExtensions = ["md", "txt", "json", "html", "css", "xml", "yml", "yaml"];

    if (imageExtensions.includes(extension)) return "image";
    if (codeExtensions.includes(extension)) return "code";
    if (textExtensions.includes(extension)) return "text";
    return "unknown";
}
</file>

<file path="src/lib/github/index.ts">
// lib/github/index.ts

// Export URL-related functions
export * from "./url";

// Export shared types
export * from "./types";

// Export contents functions
export * from "./content/getRootContents";
export * from "./content/getFileContents";
export * from "./content/getDirectoryContents";
export * from "./content/getRepoTree";

// Export visualization functions
export * from "./visualization/formatTree";
export * from "./visualization/decodeContent";
export * from "./visualization/inferFileType";
export * from "./visualization/getLanguageBreakdown"
export * from "./visualization/assignDFSIndices"
</file>

<file path="src/lib/github/types.ts">
// lib/github/types.ts

export type GitTreeNode = {
    path: string;
    mode: string;
    type: "blob" | "tree";
    sha: string;
    url: string;
};

export type GitTreeResponse = {
    sha: string;
    url: string;
    tree: GitTreeNode[];
    truncated: boolean;
};

export type GitBranch = {
    name: string;
    commit: {
        sha: string;
        commit: {
            tree: {
                sha: string;
            };
        };
    };
};

// The nested tree structure you use for visualization:
export type RepoTreeNode = {
    name: string;
    type: "file" | "dir";
    children?: RepoTreeNode[];
};
</file>

<file path="src/lib/github/url.ts">
// lib/github/url.ts

export interface GitHubRepoInfo {
    owner: string;
    repo: string;
}

/**
 * Extracts the owner and repository name from a GitHub URL.
 * Example: "https://github.com/owner/repo" or "https://github.com/owner/repo.git"
 *
 * @param url - The GitHub repository URL.
 * @returns An object containing the repository owner and name.
 * @throws Error if the URL does not match the expected GitHub URL pattern.
 */
export function extractRepoInfo(url: string): GitHubRepoInfo {
    const regex = /github\.com\/([^\/]+)\/([^\/]+)(?:\/|$)/;
    const match = regex.exec(url);
    if (!match) {
        throw new Error("Invalid GitHub URL. Ensure it includes the owner and repository name.");
    }
    // Remove .git suffix if present
    const repo = match[2].replace(/\.git$/, "");
    return {
        owner: match[1],
        repo,
    };
}

/**
 * Generates the base GitHub API URL for a given repository.
 * Example output: "https://api.github.com/repos/owner/repo"
 *
 * @param info - The GitHub repository info object.
 * @returns The base API URL.
 */
export function generateBaseApiUrl(info: GitHubRepoInfo): string {
    return `https://api.github.com/repos/${info.owner}/${info.repo}`;
}

/**
 * Builds a full GitHub API URL by appending an endpoint and optional query parameters.
 * For example, to get the repository contents you might call:
 * buildFullApiUrl(info, '/contents', { ref: 'main' })
 *
 * @param info - The GitHub repository info object.
 * @param endpoint - An endpoint to append (default is empty string).
 * @param queryParams - Optional object containing query parameters.
 * @returns The complete GitHub API URL.
 */
export function buildFullApiUrl(
    info: GitHubRepoInfo,
    endpoint = "",
    queryParams?: Record<string, string | number | boolean>
): string {
    const baseUrl = generateBaseApiUrl(info);
    let url = `${baseUrl}${endpoint}`;

    if (queryParams && Object.keys(queryParams).length > 0) {
        const queryString = Object.entries(queryParams)
            .map(
                ([key, value]) =>
                    `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`
            )
            .join("&");
        url += `?${queryString}`;
    }

    return url;
}
</file>

<file path="src/lib/shadcn/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="src/server/api/routers/github.ts">
import { z } from "zod";
import { createTRPCRouter, publicProcedure } from "../trpc";
import { extractRepoInfo, generateBaseApiUrl } from "~/lib/github/url";
import { fetchBranch } from "~/lib/github/content/fetchBranch";
import { fetchGitTree } from "~/lib/github/content/fetchGitTree";
import { buildRepoTree } from "~/lib/github/content/buildRepoTree";
import { formatRepoTreeToMarkdown } from "~/lib/github/visualization/formatTree";
import { db } from "~/server/db";

export const githubRouter = createTRPCRouter({
    getRepoTreeFormatted: publicProcedure
        .input(
            z.object({
                repoUrl: z.string().url(),
                depth: z.number().optional().default(2),
            })
        )
        .query(async ({ input }) => {
            // Extract repository info and build the base API URL.
            const repoInfo = extractRepoInfo(input.repoUrl);
            const baseUrl = generateBaseApiUrl(repoInfo);

            // Use the new function to fetch branch data.
            const branchData = await fetchBranch(baseUrl, "main");
            const treeSha = branchData.commit.commit.tree.sha;

            // Fetch the entire tree recursively.
            const treeResponse = await fetchGitTree(baseUrl, treeSha, true);

            // Build a nested tree up to the specified depth.
            const nestedTree = buildRepoTree(treeResponse.tree, input.depth);

            // Format the nested tree as Markdown.
            const markdown = formatRepoTreeToMarkdown(nestedTree);

            return { markdown };
        }),

    getRepoTree: publicProcedure
        .input(
            z.object({
                repoUrl: z.string().url(),
                depth: z.number().optional().default(5),
            })
        )
        .query(async ({ input }) => {
            // Check the cached repo tree first.
            const cached = await db.repoTree.findUnique({
                where: { repoUrl: input.repoUrl },
            });
            if (cached) {
                return cached.treeData as RepoTreeNode[];
            }
            // If no cache, fetch from GitHub.
            const repoInfo = extractRepoInfo(input.repoUrl);
            const baseUrl = generateBaseApiUrl(repoInfo);

            // Fetch branch info for the "main" branch (or use a dynamic default)
            const branchData = await fetchBranch(baseUrl, "main");
            const treeSha = branchData.commit.commit.tree.sha;

            // Fetch the entire tree recursively.
            const treeResponse = await fetchGitTree(baseUrl, treeSha, true);
            const nestedTree = buildRepoTree(treeResponse.tree, input.depth);
            return nestedTree;
        }),

    getRepoTreeCached: publicProcedure
        .input(
            z.object({
                repoUrl: z.string().url(),
                userId: z.string().optional(), // Provided only if user is logged in.
            })
        )
        .query(async ({ input }) => {
            // Check if the repo tree is already cached.
            const existing = await db.repoTree.findUnique({
                where: { repoUrl: input.repoUrl },
            });
            if (existing) {
                return { treeData: existing.treeData, id: existing.id };
            }
            // Otherwise, fetch from GitHub.
            const repoInfo = extractRepoInfo(input.repoUrl);
            const baseUrl = generateBaseApiUrl(repoInfo);
            // For simplicity, assume branch "main"
            const branchData = await fetchBranch(baseUrl, "main");
            const treeSha = branchData.commit.commit.tree.sha;
            const treeResponse = await fetchGitTree(baseUrl, treeSha, true);
            // Build the full nested tree (buildRepoTree is now updated to not require a depth limit).
            const nestedTree = buildRepoTree(treeResponse.tree);
            // Only write to the DB if a userId is provided.
            if (input.userId) {
                const newRepoTree = await db.repoTree.create({
                    data: {
                        repoUrl: input.repoUrl,
                        treeData: nestedTree,
                    },
                });
                return { treeData: nestedTree, id: newRepoTree.id };
            }
            return { treeData: nestedTree };
        }),

});
</file>

<file path="src/server/api/routers/post.ts">
import { z } from "zod";

import { createTRPCRouter, publicProcedure } from "~/server/api/trpc";

export const postRouter = createTRPCRouter({
  hello: publicProcedure
    .input(z.object({ text: z.string() }))
    .query(({ input }) => {
      return {
        greeting: `Hello ${input.text}`,
      };
    }),

  create: publicProcedure
    .input(z.object({ name: z.string().min(1) }))
    .mutation(async ({ ctx, input }) => {
      return ctx.db.post.create({
        data: {
          name: input.name,
        },
      });
    }),

  getLatest: publicProcedure.query(async ({ ctx }) => {
    const post = await ctx.db.post.findFirst({
      orderBy: { createdAt: "desc" },
    });

    return post ?? null;
  }),
});
</file>

<file path="src/server/api/trpc.ts">
/**
 * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:
 * 1. You want to modify request context (see Part 1).
 * 2. You want to create a new middleware or type of procedure (see Part 3).
 *
 * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will
 * need to use are documented accordingly near the end.
 */
import { initTRPC } from "@trpc/server";
import superjson from "superjson";
import { ZodError } from "zod";

import { db } from "~/server/db";

/**
 * 1. CONTEXT
 *
 * This section defines the "contexts" that are available in the backend API.
 *
 * These allow you to access things when processing a request, like the database, the session, etc.
 *
 * This helper generates the "internals" for a tRPC context. The API handler and RSC clients each
 * wrap this and provides the required context.
 *
 * @see https://trpc.io/docs/server/context
 */
export const createTRPCContext = async (opts: { headers: Headers }) => {
  return {
    db,
    ...opts,
  };
};

/**
 * 2. INITIALIZATION
 *
 * This is where the tRPC API is initialized, connecting the context and transformer. We also parse
 * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation
 * errors on the backend.
 */
const t = initTRPC.context<typeof createTRPCContext>().create({
  transformer: superjson,
  errorFormatter({ shape, error }) {
    return {
      ...shape,
      data: {
        ...shape.data,
        zodError:
          error.cause instanceof ZodError ? error.cause.flatten() : null,
      },
    };
  },
});

/**
 * Create a server-side caller.
 *
 * @see https://trpc.io/docs/server/server-side-calls
 */
export const createCallerFactory = t.createCallerFactory;

/**
 * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)
 *
 * These are the pieces you use to build your tRPC API. You should import these a lot in the
 * "/src/server/api/routers" directory.
 */

/**
 * This is how you create new routers and sub-routers in your tRPC API.
 *
 * @see https://trpc.io/docs/router
 */
export const createTRPCRouter = t.router;

/**
 * Middleware for timing procedure execution and adding an artificial delay in development.
 *
 * You can remove this if you don't like it, but it can help catch unwanted waterfalls by simulating
 * network latency that would occur in production but not in local development.
 */
const timingMiddleware = t.middleware(async ({ next, path }) => {
  const start = Date.now();

  if (t._config.isDev) {
    // artificial delay in dev
    const waitMs = Math.floor(Math.random() * 400) + 100;
    await new Promise((resolve) => setTimeout(resolve, waitMs));
  }

  const result = await next();

  const end = Date.now();
  console.log(`[TRPC] ${path} took ${end - start}ms to execute`);

  return result;
});

/**
 * Public (unauthenticated) procedure
 *
 * This is the base piece you use to build new queries and mutations on your tRPC API. It does not
 * guarantee that a user querying is authorized, but you can still access user session data if they
 * are logged in.
 */
export const publicProcedure = t.procedure.use(timingMiddleware);
</file>

<file path="src/server/db.ts">
import { PrismaClient } from "@prisma/client";

import { env } from "~/env";

const createPrismaClient = () =>
  new PrismaClient({
    log:
      env.NODE_ENV === "development" ? ["query", "error", "warn"] : ["error"],
  });

const globalForPrisma = globalThis as unknown as {
  prisma: ReturnType<typeof createPrismaClient> | undefined;
};

export const db = globalForPrisma.prisma ?? createPrismaClient();

if (env.NODE_ENV !== "production") globalForPrisma.prisma = db;
</file>

<file path="src/trpc/query-client.ts">
import {
  defaultShouldDehydrateQuery,
  QueryClient,
} from "@tanstack/react-query";
import SuperJSON from "superjson";

export const createQueryClient = () =>
  new QueryClient({
    defaultOptions: {
      queries: {
        // With SSR, we usually want to set some default staleTime
        // above 0 to avoid refetching immediately on the client
        staleTime: 30 * 1000,
      },
      dehydrate: {
        serializeData: SuperJSON.serialize,
        shouldDehydrateQuery: (query) =>
          defaultShouldDehydrateQuery(query) ||
          query.state.status === "pending",
      },
      hydrate: {
        deserializeData: SuperJSON.deserialize,
      },
    },
  });
</file>

<file path="src/trpc/react.tsx">
"use client";

import { QueryClientProvider, type QueryClient } from "@tanstack/react-query";
import { loggerLink, unstable_httpBatchStreamLink } from "@trpc/client";
import { createTRPCReact } from "@trpc/react-query";
import { type inferRouterInputs, type inferRouterOutputs } from "@trpc/server";
import { useState } from "react";
import SuperJSON from "superjson";

import { type AppRouter } from "~/server/api/root";
import { createQueryClient } from "./query-client";

let clientQueryClientSingleton: QueryClient | undefined = undefined;
const getQueryClient = () => {
  if (typeof window === "undefined") {
    // Server: always make a new query client
    return createQueryClient();
  }
  // Browser: use singleton pattern to keep the same query client
  return (clientQueryClientSingleton ??= createQueryClient());
};

export const api = createTRPCReact<AppRouter>();

/**
 * Inference helper for inputs.
 *
 * @example type HelloInput = RouterInputs['example']['hello']
 */
export type RouterInputs = inferRouterInputs<AppRouter>;

/**
 * Inference helper for outputs.
 *
 * @example type HelloOutput = RouterOutputs['example']['hello']
 */
export type RouterOutputs = inferRouterOutputs<AppRouter>;

export function TRPCReactProvider(props: { children: React.ReactNode }) {
  const queryClient = getQueryClient();

  const [trpcClient] = useState(() =>
    api.createClient({
      links: [
        loggerLink({
          enabled: (op) =>
            process.env.NODE_ENV === "development" ||
            (op.direction === "down" && op.result instanceof Error),
        }),
        unstable_httpBatchStreamLink({
          transformer: SuperJSON,
          url: getBaseUrl() + "/api/trpc",
          headers: () => {
            const headers = new Headers();
            headers.set("x-trpc-source", "nextjs-react");
            return headers;
          },
        }),
      ],
    })
  );

  return (
    <QueryClientProvider client={queryClient}>
      <api.Provider client={trpcClient} queryClient={queryClient}>
        {props.children}
      </api.Provider>
    </QueryClientProvider>
  );
}

function getBaseUrl() {
  if (typeof window !== "undefined") return window.location.origin;
  if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`;
  return `http://localhost:${process.env.PORT ?? 3000}`;
}
</file>

<file path="src/trpc/server.ts">
import "server-only";

import { createHydrationHelpers } from "@trpc/react-query/rsc";
import { headers } from "next/headers";
import { cache } from "react";

import { createCaller, type AppRouter } from "~/server/api/root";
import { createTRPCContext } from "~/server/api/trpc";
import { createQueryClient } from "./query-client";

/**
 * This wraps the `createTRPCContext` helper and provides the required context for the tRPC API when
 * handling a tRPC call from a React Server Component.
 */
const createContext = cache(async () => {
  const heads = new Headers(await headers());
  heads.set("x-trpc-source", "rsc");

  return createTRPCContext({
    headers: heads,
  });
});

const getQueryClient = cache(createQueryClient);
const caller = createCaller(createContext);

export const { trpc: api, HydrateClient } = createHydrationHelpers<AppRouter>(
  caller,
  getQueryClient
);
</file>

<file path=".env.example">
# Since the ".env" file is gitignored, you can use the ".env.example" file to
# build a new ".env" file when you clone the repo. Keep this file up-to-date
# when you add new variables to `.env`.

# This file will be committed to version control, so make sure not to have any
# secrets in it. If you are cloning this repo, create a copy of this file named
# ".env" and populate it with your secrets.

# When adding additional environment variables, the schema in "/src/env.js"
# should be updated accordingly.

# Prisma
# https://www.prisma.io/docs/reference/database-reference/connection-urls#env
DATABASE_URL="file:./db.sqlite"
</file>

<file path=".eslintrc.cjs">
/** @type {import("eslint").Linter.Config} */
const config = {
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "project": true
  },
  "plugins": [
    "@typescript-eslint"
  ],
  "extends": [
    "next/core-web-vitals",
    "plugin:@typescript-eslint/recommended-type-checked",
    "plugin:@typescript-eslint/stylistic-type-checked"
  ],
  "rules": {
    "@typescript-eslint/array-type": "off",
    "@typescript-eslint/consistent-type-definitions": "off",
    "@typescript-eslint/consistent-type-imports": [
      "warn",
      {
        "prefer": "type-imports",
        "fixStyle": "inline-type-imports"
      }
    ],
    "@typescript-eslint/no-unused-vars": [
      "warn",
      {
        "argsIgnorePattern": "^_"
      }
    ],
    "@typescript-eslint/require-await": "off",
    "@typescript-eslint/no-misused-promises": [
      "error",
      {
        "checksVoidReturn": {
          "attributes": false
        }
      }
    ]
  }
}
module.exports = config;
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# database
/prisma/db.sqlite
/prisma/db.sqlite-journal
db.sqlite

# next.js
/.next/
/out/
next-env.d.ts

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# local env files
# do not commit any .env files to git, except for the .env.example file. https://create.t3.gg/en/usage/env-variables#using-environment-variables
.env
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo

# idea files
.idea
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/styles/globals.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "~/components",
    "utils": "~/lib/shadcn/utils",
    "ui": "~/components/ui",
    "lib": "~/lib",
    "hooks": "~/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="next.config.js">
/**
 * Run `build` or `dev` with `SKIP_ENV_VALIDATION` to skip env validation. This is especially useful
 * for Docker builds.
 */
import "./src/env.js";

/** @type {import("next").NextConfig} */
const config = {};

export default config;
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
  },
};
</file>

<file path="prettier.config.js">
/** @type {import('prettier').Config & import('prettier-plugin-tailwindcss').PluginOptions} */
export default {
  plugins: ["prettier-plugin-tailwindcss"],
};
</file>

<file path="README.md">
# Create T3 App

This is a [T3 Stack](https://create.t3.gg/) project bootstrapped with `create-t3-app`.

## What's next? How do I make an app with this?

We try to keep this project as simple as possible, so you can start with just the scaffolding we set up for you, and add additional things later when they become necessary.

If you are not familiar with the different technologies used in this project, please refer to the respective docs. If you still are in the wind, please join our [Discord](https://t3.gg/discord) and ask for help.

- [Next.js](https://nextjs.org)
- [NextAuth.js](https://next-auth.js.org)
- [Prisma](https://prisma.io)
- [Drizzle](https://orm.drizzle.team)
- [Tailwind CSS](https://tailwindcss.com)
- [tRPC](https://trpc.io)

## Learn More

To learn more about the [T3 Stack](https://create.t3.gg/), take a look at the following resources:

- [Documentation](https://create.t3.gg/)
- [Learn the T3 Stack](https://create.t3.gg/en/faq#what-learning-resources-are-currently-available) — Check out these awesome tutorials

You can check out the [create-t3-app GitHub repository](https://github.com/t3-oss/create-t3-app) — your feedback and contributions are welcome!

## How do I deploy this?

Follow our deployment guides for [Vercel](https://create.t3.gg/en/deployment/vercel), [Netlify](https://create.t3.gg/en/deployment/netlify) and [Docker](https://create.t3.gg/en/deployment/docker) for more information.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    /* Base Options: */
    "esModuleInterop": true,
    "skipLibCheck": true,
    "target": "es2022",
    "allowJs": true,
    "resolveJsonModule": true,
    "moduleDetection": "force",
    "isolatedModules": true,

    /* Strictness */
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "checkJs": true,

    /* Bundled projects */
    "lib": ["dom", "dom.iterable", "ES2022"],
    "noEmit": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "jsx": "preserve",
    "plugins": [{ "name": "next" }],
    "incremental": true,

    /* Path Aliases */
    "baseUrl": ".",
    "paths": {
      "~/*": ["./src/*"]
    }
  },
  "include": [
    ".eslintrc.cjs",
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    "**/*.cjs",
    "**/*.js",
    ".next/types/**/*.ts"
  ],
  "exclude": ["node_modules"]
}
</file>

<file path="prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Post {
  id        Int      @id @default(autoincrement())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
}

// Better-Auth + User Data

model User {
  id            String    @id
  name          String
  email         String
  emailVerified Boolean
  image         String?
  createdAt     DateTime?
  updatedAt     DateTime?
  Session       Session[]
  Account       Account[]

  role       String?
  banned     Boolean?
  banReason  String?
  banExpires DateTime?

  firstName String?
  lastName  String?
  phone     String?

  reports Report[]

  @@unique([email])
  @@map("user")
}

// Report Data

model RepoTree {
  id        String   @id @default(cuid())
  repoUrl   String   @unique
  treeData  Json
  updatedAt DateTime @updatedAt
  reports   Report[] // Inverse relation field
}

model Report {
  id         String   @id @default(cuid())
  repoUrl    String
  repoTreeId String
  repoTree   RepoTree @relation(fields: [repoTreeId], references: [id])
  userId     String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  User       User     @relation(fields: [userId], references: [id])
}

// Better-Auth

model Session {
  id        String    @id
  expiresAt DateTime
  token     String
  createdAt DateTime?
  updatedAt DateTime?
  ipAddress String?
  userAgent String?
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  impersonatedBy String?

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime?
  updatedAt             DateTime?

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}
</file>

<file path="src/app/api/trpc/[trpc]/route.ts">
import { fetchRequestHandler } from "@trpc/server/adapters/fetch";
import { type NextRequest } from "next/server";

import { env } from "~/env";
import { appRouter } from "~/server/api/root";
import { createTRPCContext } from "~/server/api/trpc";

/**
 * This wraps the `createTRPCContext` helper and provides the required context for the tRPC API when
 * handling an HTTP request (e.g. when you make requests from Client Components).
 */
const createContext = async (req: NextRequest) => {
  return createTRPCContext({
    headers: req.headers,
  });
};

const handler = (req: NextRequest) =>
  fetchRequestHandler({
    endpoint: "/api/trpc",
    req,
    router: appRouter,
    createContext: () => createContext(req),
    onError:
      env.NODE_ENV === "development"
        ? ({ path, error }) => {
            console.error(
              `❌ tRPC failed on ${path ?? "<no-path>"}: ${error.message}`
            );
          }
        : undefined,
  });

export { handler as GET, handler as POST };
</file>

<file path="src/app/dashboard/new/page.tsx">
"use client";

import { useSearchParams } from "next/navigation";
import { useRepoReport } from "~/hooks/useRepoReport";
import { FileExplorer } from "~/components/file-explorer";

export default function NewReportPage() {
    const searchParams = useSearchParams();
    const repoUrl = searchParams.get("repoUrl");

    const { treeData, isLoading, error } = useRepoReport(repoUrl, 5);

    if (!repoUrl) {
        return (
            <main className="p-4">
                <h1 className="text-4xl font-bold">New Report</h1>
                <p>No repository URL provided.</p>
            </main>
        );
    }

    return (
        <main className="container mx-auto p-4">
            <h1 className="text-4xl font-bold mb-4">Repository Structure</h1>
            {isLoading && <p>Loading repository structure...</p>}
            {error && <p className="text-destructive">Error: {error.message}</p>}
            {treeData && (
                <div className="mt-4">
                    <FileExplorer tree={treeData} delay={300} defaultExpanded={true} />
                </div>
            )}
        </main>
    );
}
</file>

<file path="src/app/login/page.tsx">
"use client";

import { useSearchParams } from "next/navigation";
import { Separator } from "~/components/ui/separator";
import { LoginBox } from "~/components/auth/login-box";
import { useRepoReport } from "~/hooks/useRepoReport";
import { FileExplorer } from "~/components/file-explorer";

export default function LoginPage() {
    const searchParams = useSearchParams();
    const repoUrl = searchParams.get("repoUrl") ?? null;

    // useRepoReport now returns a title along with treeData.
    const { treeData, isLoading, error, title } = useRepoReport(repoUrl);

    return (
        <main className="container mx-auto flex h-[calc(100vh-4rem)]">
            {/* Left side: Login UI */}
            <div className="flex flex-1 flex-col items-center justify-center p-8">
                <LoginBox repoUrl={repoUrl} />
            </div>

            <Separator orientation="vertical" />

            {repoUrl ? (
                // Render the "New Report Preview" placeholder with the repo tree and title.
                <div className="flex flex-1 flex-col items-start justify-start p-8 w-full h-full overflow-hidden">
                    {isLoading && <p>Loading repository structure...</p>}
                    {error && (
                        <p className="text-destructive">Error: {error.message}</p>
                    )}
                    {treeData && (
                        <div className="w-full h-[calc(100%-5rem)]">
                            <FileExplorer tree={treeData} title={title} delay={100} defaultExpanded={true} />
                        </div>
                    )}
                </div>
            ) : (
                // Default placeholder if no repo URL is provided.
                <div className="flex flex-1 flex-col items-start justify-start p-8 w-full">
                    <div className="w-full">
                        <h1 className="mb-8 text-3xl font-semibold">Welcome Back</h1>
                        {/* Additional UI for non-repo users */}
                    </div>
                </div>
            )}
        </main>
    );
}
</file>

<file path="src/app/layout.tsx">
import "~/styles/globals.css";

import { GeistSans } from "geist/font/sans";
import { type Metadata } from "next";

import { TRPCReactProvider } from "~/trpc/react";
import { NavBar } from "~/components/navigation/nav-bar";

export const metadata: Metadata = {
  title: "CodeBrief",
  description: "Explain new codebases instantly",
  icons: [{ rel: "icon", url: "/favicon.ico" }],
};

export default function RootLayout({
  children,
}: Readonly<{ children: React.ReactNode }>) {
  return (
    <html lang="en" className={GeistSans.variable}>
      <body className="min-h-screen bg-background">
        <TRPCReactProvider>
          <NavBar />
          {children}
        </TRPCReactProvider>
      </body>
    </html>
  );
}
</file>

<file path="src/components/auth/login-box.tsx">
"use client";

import { Card, CardContent, CardHeader } from "~/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "~/components/ui/tabs";
import { SignInForm } from "./sign-in-form";
import { SignUpForm } from "./sign-up-form";

export function LoginBox( { repoUrl }: { repoUrl: string | null } ) {
  return (
    <Card className="w-full max-w-sm">
      <CardHeader className="space-y-1">
        <Tabs defaultValue="sign-in" className="w-full">
          <TabsList className="grid w-full grid-cols-2">
            <TabsTrigger value="sign-in">Sign In</TabsTrigger>
            <TabsTrigger value="sign-up">Sign Up</TabsTrigger>
          </TabsList>
          <TabsContent value="sign-in" className="mt-4">
            <SignInForm repoUrl={repoUrl} />
          </TabsContent>
          <TabsContent value="sign-up" className="mt-4">
            <SignUpForm repoUrl={repoUrl} />
          </TabsContent>
        </Tabs>
      </CardHeader>
      <CardContent>
        <p className="px-8 text-center text-sm text-muted-foreground">
          By continuing, you agree to our{" "}
          <a
            href="/terms"
            className="underline underline-offset-4 hover:text-primary"
          >
            Terms of Service
          </a>{" "}
          and{" "}
          <a
            href="/privacy"
            className="underline underline-offset-4 hover:text-primary"
          >
            Privacy Policy
          </a>
          .
        </p>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/auth/sign-in-form.tsx">
"use client";

import { useState } from "react";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { useRouter } from "next/navigation";
import { z } from "zod";
import { cn } from "~/lib/shadcn/utils";
import { Loader2 } from "lucide-react";

import { signIn } from "~/lib/auth/auth-client";
import { Button } from "~/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "~/components/ui/form";
import { Input } from "~/components/ui/input";

const formSchema = z.object({
  email: z.string().email("Invalid email address"),
  password: z.string().min(1, "Password is required"),
});

export function SignInForm({ repoUrl }: { repoUrl: string | null }) {
  const [shake, setShake] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      email: "",
      password: "",
    },
  });

  async function onSubmit(values: z.infer<typeof formSchema>) {
    setIsLoading(true);
    try {
      const result = await signIn.email(values);
      
      if (result.error) {
        throw result.error;
      }

      router.push(
        repoUrl
          ? `/dashboard/new?repoUrl=${encodeURIComponent(repoUrl)}`
          : "/dashboard"
      );
    } catch (error) {
      setShake(true);
      setTimeout(() => setShake(false), 500);
      form.setError("root", {
        message: "Invalid email or password",
      });
    } finally {
      setIsLoading(false);
    }
  }

  return (
    <Form {...form}>
      <form
        onSubmit={form.handleSubmit(onSubmit)}
        className={cn("space-y-4", shake && "animate-shake")}
      >
        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <Input placeholder="email@example.com" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="password"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Password</FormLabel>
              <FormControl>
                <Input type="password" placeholder="********" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <Button type="submit" className="w-full" disabled={isLoading}>
          {isLoading ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              Signing In
            </>
          ) : (
            "Sign In"
          )}
        </Button>
      </form>
    </Form>
  );
}
</file>

<file path="src/components/auth/sign-up-form.tsx">
"use client";

import { useState } from "react";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { useRouter } from "next/navigation";
import { z } from "zod";
import { cn } from "~/lib/shadcn/utils";
import { Loader2 } from "lucide-react";

import { signUp } from "~/lib/auth/auth-client";
import { Button } from "~/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "~/components/ui/form";
import { Input } from "~/components/ui/input";

const formSchema = z.object({
  email: z.string().email("Invalid email address"),
  username: z.string().min(3, "Username must be at least 3 characters"),
  password: z
    .string()
    .min(8, "Password must be at least 8 characters")
    .regex(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/,
      "Password must contain uppercase, lowercase, and number"
    ),
});

export function SignUpForm({ repoUrl }: { repoUrl: string | null }) {
  const [shake, setShake] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      email: "",
      username: "",
      password: "",
    },
  });

  console.log("Form state:", {
    isDirty: form.formState.isDirty,
    errors: form.formState.errors,
    isValid: form.formState.isValid,
  });

  async function onSubmit(values: z.infer<typeof formSchema>) {
    setIsLoading(true);
    try {
      const result = await signUp.email({
        email: values.email,
        password: values.password,
        name: values.username,
      });

      if (result.error) {
        throw result.error;
      }

      router.push(
        repoUrl
          ? `/dashboard/new?repoUrl=${encodeURIComponent(repoUrl)}`
          : "/dashboard"
      );
    } catch (error) {
      setShake(true);
      setTimeout(() => setShake(false), 500);
      form.setError("root", {
        message: "Failed to create account. Please try again.",
      });
    } finally {
      setIsLoading(false);
    }
  }

  return (
    <Form {...form}>
      <form
        onSubmit={form.handleSubmit(onSubmit)}
        className={cn("space-y-4", shake && "animate-shake")}
      >
        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <Input placeholder="email@example.com" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="username"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Username</FormLabel>
              <FormControl>
                <Input placeholder="johndoe" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="password"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Password</FormLabel>
              <FormControl>
                <Input type="password" placeholder="********" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        {form.formState.errors.root && (
          <p className="text-sm text-destructive">{form.formState.errors.root.message}</p>
        )}
        <Button type="submit" className="w-full" disabled={isLoading}>
          {isLoading ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              Creating Account
            </>
          ) : (
            "Create Account"
          )}
        </Button>
      </form>
    </Form>
  );
}
</file>

<file path="src/server/api/root.ts">
import { postRouter } from "~/server/api/routers/post";
import { createCallerFactory, createTRPCRouter } from "~/server/api/trpc";
import {githubRouter} from "~/server/api/routers/github";
import {reportRouter} from "~/server/api/routers/report";

/**
 * This is the primary router for your server.
 *
 * All routers added in /api/routers should be manually added here.
 */
export const appRouter = createTRPCRouter({
  post: postRouter,
  github: githubRouter,
  report: reportRouter,
});

// export type definition of API
export type AppRouter = typeof appRouter;

/**
 * Create a server-side caller for the tRPC API.
 * @example
 * const trpc = createCaller(createContext);
 * const res = await trpc.post.all();
 *       ^? Post[]
 */
export const createCaller = createCallerFactory(appRouter);
</file>

<file path="src/styles/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem
  }
  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-10px); }
  75% { transform: translateX(10px); }
}

.animate-shake {
  animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
}
</file>

<file path="src/env.js">
import { createEnv } from "@t3-oss/env-nextjs";
import { z } from "zod";

export const env = createEnv({
  /**
   * Specify your server-side environment variables schema here. This way you can ensure the app
   * isn't built with invalid env vars.
   */
  server: {
    DATABASE_URL: z.string().url(),
    NODE_ENV: z
      .enum(["development", "test", "production"])
      .default("development"),
    BETTER_AUTH_SECRET: z.string().min(1, "BETTER_AUTH_SECRET is required"),
    BETTER_AUTH_URL: z.string().url("BETTER_AUTH_URL must be a valid URL"),
  },

  /**
   * Specify your client-side environment variables schema here. This way you can ensure the app
   * isn't built with invalid env vars. To expose them to the client, prefix them with
   * `NEXT_PUBLIC_`.
   */
  client: {
    NEXT_PUBLIC_BETTER_AUTH_URL: z
    .string()
    .url("NEXT_PUBLIC_BETTER_AUTH_URL must be a valid URL"),
  },

  /**
   * You can't destruct `process.env` as a regular object in the Next.js edge runtimes (e.g.
   * middlewares) or client-side, so we need to destruct manually.
   */
  runtimeEnv: {
    DATABASE_URL: process.env.DATABASE_URL,
    NODE_ENV: process.env.NODE_ENV,
    BETTER_AUTH_SECRET: process.env.BETTER_AUTH_SECRET,
    BETTER_AUTH_URL: process.env.BETTER_AUTH_URL,
    NEXT_PUBLIC_BETTER_AUTH_URL: process.env.NEXT_PUBLIC_BETTER_AUTH_URL,
    // NEXT_PUBLIC_CLIENTVAR: process.env.NEXT_PUBLIC_CLIENTVAR,
  },
  /**
   * Run `build` or `dev` with `SKIP_ENV_VALIDATION` to skip env validation. This is especially
   * useful for Docker builds.
   */
  skipValidation: !!process.env.SKIP_ENV_VALIDATION,
  /**
   * Makes it so that empty strings are treated as undefined. `SOME_VAR: z.string()` and
   * `SOME_VAR=''` will throw an error.
   */
  emptyStringAsUndefined: true,
});
</file>

<file path="tailwind.config.ts">
import { type Config } from "tailwindcss";
import { fontFamily } from "tailwindcss/defaultTheme";

export default {
    darkMode: ["class"],
    content: ["./src/**/*.tsx"],
  theme: {
  	extend: {
  		fontFamily: {
  			sans: [
  				'var(--font-geist-sans)',
                    ...fontFamily.sans
                ]
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config;
</file>

<file path="src/app/page.tsx">
"use client";

import { ArrowRight } from "lucide-react";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { Button } from "~/components/ui/button";
import { Input } from "~/components/ui/input";
import { useSession } from "~/lib/auth/auth-client";

function isValidUrl(url: string) {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}

export default function Home() {
  const router = useRouter();
  const { data: session } = useSession();
  const [url, setUrl] = useState("");
  const isValid = url.trim() === "" || isValidUrl(url);

  return (
    <main className="flex min-h-[calc(100vh-4rem)] flex-col items-center justify-center p-4">
      <div className="container flex max-w-2xl flex-col items-center gap-8">
        <h1 className="text-center text-4xl font-bold tracking-tight sm:text-6xl">
          Explain New Codebases
        </h1>
        
        <div className="w-full max-w-lg space-y-2">
          <form 
            className="flex w-full gap-2"
            onSubmit={(e) => {
              e.preventDefault();
              const target = session 
                ? `/dashboard/new?repoUrl=${encodeURIComponent(url)}`
                : `/login?repoUrl=${encodeURIComponent(url)}`;
              router.push(target);
            }}
          >
            <Input
              type="text"
              placeholder="paste public github url"
              className="flex-1"
              value={url}
              onChange={(e) => setUrl(e.target.value)}
            />
            <Button type="submit" disabled={!isValidUrl(url)}>
              <ArrowRight className="h-4 w-4" />
            </Button>
          </form>
          {url && !isValid && (
            <p className="text-sm text-destructive">Please enter a valid URL</p>
          )}
        </div>
      </div>
    </main>
  );
}
</file>

<file path="package.json">
{
  "name": "CodeBrief",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "next build",
    "check": "next lint && tsc --noEmit",
    "db:generate": "prisma migrate dev",
    "db:migrate": "prisma migrate deploy",
    "db:push": "prisma db push",
    "db:studio": "prisma studio",
    "dev": "next dev --turbo",
    "format:check": "prettier --check \"**/*.{ts,tsx,js,jsx,mdx}\" --cache",
    "format:write": "prettier --write \"**/*.{ts,tsx,js,jsx,mdx}\" --cache",
    "postinstall": "prisma generate",
    "lint": "next lint",
    "lint:fix": "next lint --fix",
    "preview": "next build && next start",
    "start": "next start",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@hookform/resolvers": "^4.1.3",
    "@prisma/client": "^6.5.0",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-dropdown-menu": "^2.1.6",
    "@radix-ui/react-label": "^2.1.2",
    "@radix-ui/react-scroll-area": "^1.2.3",
    "@radix-ui/react-separator": "^1.1.2",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-tabs": "^1.1.3",
    "@t3-oss/env-nextjs": "^0.10.1",
    "@tanstack/react-query": "^5.50.0",
    "@trpc/client": "^11.0.0-rc.446",
    "@trpc/react-query": "^11.0.0-rc.446",
    "@trpc/server": "^11.0.0-rc.446",
    "better-auth": "^1.2.4",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "geist": "^1.3.0",
    "lucide-react": "^0.483.0",
    "next": "^15.0.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.54.2",
    "react-markdown": "^10.1.0",
    "server-only": "^0.0.1",
    "superjson": "^2.2.1",
    "tailwind-merge": "^3.0.2",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@types/eslint": "^8.56.10",
    "@types/node": "^20.14.10",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@typescript-eslint/eslint-plugin": "^8.1.0",
    "@typescript-eslint/parser": "^8.1.0",
    "eslint": "^8.57.0",
    "eslint-config-next": "^15.0.1",
    "postcss": "^8.4.39",
    "prettier": "^3.3.2",
    "prettier-plugin-tailwindcss": "^0.6.5",
    "prisma": "^6.5.0",
    "tailwindcss": "^3.4.3",
    "typescript": "^5.5.3"
  },
  "ct3aMetadata": {
    "initVersion": "7.38.1"
  },
  "packageManager": "npm@10.2.4"
}
</file>

</files>
